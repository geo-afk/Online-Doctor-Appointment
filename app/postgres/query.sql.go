// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAddress = `-- name: CreateAddress :exec
INSERT INTO
    address (street, city, state, country, zip)
VALUES
    ($1, $2, $3, $4, $5)
`

type CreateAddressParams struct {
	Street  pgtype.Text
	City    pgtype.Text
	State   pgtype.Text
	Country pgtype.Text
	Zip     pgtype.Text
}

func (q *Queries) CreateAddress(ctx context.Context, arg CreateAddressParams) error {
	_, err := q.db.Exec(ctx, createAddress,
		arg.Street,
		arg.City,
		arg.State,
		arg.Country,
		arg.Zip,
	)
	return err
}

const createContact = `-- name: CreateContact :one
INSERT INTO
    contact_details (primary_number, secondary_number, email)
VALUES
    ($1, $2, $3) RETURNING id
`

type CreateContactParams struct {
	PrimaryNumber   pgtype.Text
	SecondaryNumber pgtype.Text
	Email           pgtype.Text
}

// Create
func (q *Queries) CreateContact(ctx context.Context, arg CreateContactParams) (int32, error) {
	row := q.db.QueryRow(ctx, createContact, arg.PrimaryNumber, arg.SecondaryNumber, arg.Email)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createUserAuth = `-- name: CreateUserAuth :exec
INSERT into
    auth(user_id, user_name, password)
VALUES
    ($1, $2, $3)
`

type CreateUserAuthParams struct {
	UserID   int32
	UserName string
	Password string
}

func (q *Queries) CreateUserAuth(ctx context.Context, arg CreateUserAuthParams) error {
	_, err := q.db.Exec(ctx, createUserAuth, arg.UserID, arg.UserName, arg.Password)
	return err
}

const insertSession = `-- name: InsertSession :exec
INSERT INTO 
    "session" (
        user_id, 
        user_role, 
        refresh_token, 
        is_revoked, 
        created_at, 
        expired_at
    )
VALUES
    ($1, $2, $3, $4, $5, $6)
`

type InsertSessionParams struct {
	UserID       int32
	UserRole     URole
	RefreshToken string
	IsRevoked    bool
	CreatedAt    pgtype.Timestamp
	ExpiredAt    pgtype.Timestamp
}

func (q *Queries) InsertSession(ctx context.Context, arg InsertSessionParams) error {
	_, err := q.db.Exec(ctx, insertSession,
		arg.UserID,
		arg.UserRole,
		arg.RefreshToken,
		arg.IsRevoked,
		arg.CreatedAt,
		arg.ExpiredAt,
	)
	return err
}

const isUserLoggedIn = `-- name: IsUserLoggedIn :one
SELECT EXISTS (
    select 1
    from public.auth a
    join public.user u on a.user_id = u.id
    where u.user_role=$1 AND a.user_name=$2
) AS exists
`

type IsUserLoggedInParams struct {
	UserRole URole
	UserName string
}

func (q *Queries) IsUserLoggedIn(ctx context.Context, arg IsUserLoggedInParams) (bool, error) {
	row := q.db.QueryRow(ctx, isUserLoggedIn, arg.UserRole, arg.UserName)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const registerUser = `-- name: RegisterUser :one
INSERT INTO
    "user" (
        first_name,
        last_name,
        location,
        user_role,
        contact_id,
        emergency_contact,
        created_at
    )
VALUES
    ($1, $2, $3, $4, $5, $6, $7) RETURNING id
`

type RegisterUserParams struct {
	FirstName        string
	LastName         string
	Location         pgtype.Text
	UserRole         URole
	ContactID        pgtype.Int4
	EmergencyContact pgtype.Int4
	CreatedAt        pgtype.Timestamp
}

func (q *Queries) RegisterUser(ctx context.Context, arg RegisterUserParams) (int32, error) {
	row := q.db.QueryRow(ctx, registerUser,
		arg.FirstName,
		arg.LastName,
		arg.Location,
		arg.UserRole,
		arg.ContactID,
		arg.EmergencyContact,
		arg.CreatedAt,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const userLogin = `-- name: UserLogin :one
SELECT
    u.user_role,
    a.password
FROM
    "user" AS u
    JOIN auth AS a ON a.user_id = u.id
WHERE
    a.user_name = $1
`

type UserLoginRow struct {
	UserRole URole
	Password string
}

func (q *Queries) UserLogin(ctx context.Context, userName string) (UserLoginRow, error) {
	row := q.db.QueryRow(ctx, userLogin, userName)
	var i UserLoginRow
	err := row.Scan(&i.UserRole, &i.Password)
	return i, err
}
